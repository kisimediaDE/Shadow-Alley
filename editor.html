<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Shadow Alley – Level Editor</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0b0d12;
        color: #dbe0ea;
        font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      }
      .wrap {
        display: grid;
        grid-template-columns: 1fr 50vw;
        gap: 16px;
        padding: 16px;
        box-sizing: border-box;
      }
      @media (max-width: 980px) {
        .wrap {
          grid-template-columns: 1fr;
        }
      }
      h1 {
        margin: 0 0 8px;
        font-size: 18px;
        font-weight: 600;
      }
      .hint {
        opacity: 0.8;
        font-size: 14px;
      }
      .kbd {
        padding: 2px 6px;
        border: 1px solid #384152;
        border-bottom-width: 2px;
        border-radius: 6px;
        background: #0f1320;
        color: #c7cee0;
      }
      .tool.selected {
        outline: 2px solid #9ec5ff;
      }
      .panel {
        background: #0f1320;
        border: 1px solid #384152;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35),
          inset 0 0 0 1px rgba(255, 255, 255, 0.04);
      }
      .left {
        padding: 12px;
      }
      textarea {
        width: 100%;
        background: #0b0f1a;
        color: #dbe0ea;
        border: 1px solid #384152;
        border-radius: 8px;
        padding: 10px;
        font: 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        line-height: 1.1;
        white-space: pre;
        box-sizing: border-box;
      }
      .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 10px 0;
      }
      button {
        cursor: pointer;
      }
      .right {
        display: grid;
        gap: 10px;
      }
      canvas {
        text-align: center;
        margin: 3rem auto;
        background: #121621;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45),
          inset 0 0 0 1px rgba(255, 255, 255, 0.04);
      }
      .gridInfo {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 6px;
        font-size: 13px;
      }
      .badge {
        background: #1a2130;
        border: 1px solid #3a4255;
        border-radius: 6px;
        padding: 6px 8px;
      }
      .ok {
        color: #9be49b;
      }
      .warn {
        color: #ffd166;
      }
      .err {
        color: #ff8b8b;
      }
      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 13px;
      }
      .pill {
        background: #0e1422;
        border: 1px solid #2f3850;
        border-radius: 12px;
        padding: 4px 8px;
      }
      a {
        color: #9ec5ff;
        text-decoration: none;
      }
      hr {
        margin: 2rem 0px;
        opacity: 0.2;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="left panel">
        <h1>ASCII Level Editor</h1>
        <div class="toolbar" id="lvlControls">
          <label for="levelSel" class="hint">Level:</label>
          <select id="levelSel" class="kbd" style="min-width: 140px"></select>
          <button id="btnLevelAdd" class="kbd" title="Neues Level anhängen">
            + Neu
          </button>
          <button
            id="btnLevelDelete"
            class="kbd"
            title="Aktuelles Level löschen"
          >
            Löschen
          </button>
          <button
            id="btnSaveAll"
            class="kbd"
            title="Alle Levels nach levels.js speichern"
          >
            Speichern → levels.js
          </button>
          <button
            id="btnOpenFS"
            class="kbd"
            title="levels.js öffnen (Datei wählen)"
          >
            Datei öffnen
          </button>
          <button
            id="btnSaveFS"
            class="kbd"
            title="levels.js direkt speichern (ohne Download)"
          >
            Speichern (ohne Download)
          </button>
        </div>
        <textarea
          id="txt"
          rows="20"
          spellcheck="false"
          readonly="true"
        ></textarea>
        <div id="palette" class="toolbar">
          <span class="hint" style="align-self: center">Pinsel:</span>
          <button class="kbd tool" data-ch="#" title="# = Mauer">Mauer</button>
          <button class="kbd tool" data-ch="." title=". = Boden">Boden</button>
          <button class="kbd tool" data-ch="s" title="s = Versteck">
            Versteck
          </button>
          <button class="kbd tool" data-ch="l" title="l = Lampe">Lampe</button>
          <button class="kbd tool" data-ch="L" title="L = Hund">Hund</button>
          <button class="kbd tool" data-ch="f" title="f = Fisch">Fisch</button>
          <button class="kbd tool" data-ch="x" title="x = Tür">Tür</button>
          <button class="kbd tool" data-ch="c" title="c = Start">Start</button>
          <button class="kbd tool" data-ch="erase" title="Radierer">
            Radierer
          </button>
          <span class="hint" style="margin-left: auto"
            >Tipp: Linksklick = malen, Rechtsklick = radieren, Halten & ziehen =
            fluten. Zahlentasten 1–8 wählen den Pinsel.</span
          >
        </div>
        <hr />
        <div class="hint" style="margin: 8px 0 4px 0">
          Hint/Tutorial-Text für dieses Level:
        </div>
        <input
          id="hint"
          type="text"
          placeholder="Sammle alle Fische und gehe zur Tür."
          style="
            width: 100%;
            box-sizing: border-box;
            height: 32px;
            background: #0b0f1a;
            color: #dbe0ea;
            border: 1px solid #384152;
            border-radius: 8px;
            padding: 6px 10px;
            font: 13px system-ui, sans-serif;
          "
        />
        <hr />
        <div class="toolbar">
          <button id="btnPreview" class="kbd">Vorschau (Alt+Enter)</button>
          <button id="btnValidate" class="kbd">Validieren</button>
          <button id="btnExportJS" class="kbd">Export → levels.js</button>
          <button id="btnExportTXT" class="kbd">Export → TXT</button>
          <button id="btnCopy" class="kbd">In Zwischenablage</button>
          <span class="hint" style="margin-left: auto"
            >Tipp: <span class="kbd">Alt</span>+<span class="kbd">Enter</span> =
            Vorschau</span
          >
        </div>
      </div>

      <div class="right">
        <div class="panel" style="padding: 12px">
          <div class="gridInfo">
            <div class="badge" id="valStart">Start (c): –</div>
            <div class="badge" id="valExit">Tür (x): –</div>
            <div class="badge" id="valRect">Rechteckig: –</div>
            <div class="badge" id="valChars">Zeichen gültig: –</div>
          </div>
        </div>
        <canvas
          id="preview"
          width="480"
          height="320"
          aria-label="Vorschau"
        ></canvas>
        <div class="panel" style="padding: 12px">
          <div class="gridInfo">
            <span class="pill">Breite: <span id="infoW">0</span></span>
            <span class="pill">Höhe: <span id="infoH">0</span></span>
            <span class="pill">Fische: <span id="infoF">0</span></span>
            <span class="pill">Lampen: <span id="infoSl">0</span></span>
            <span class="pill">Hunde: <span id="infoGl">0</span></span>
            <span class="pill">Verstecke: <span id="infoS">0</span></span>
          </div>
        </div>
      </div>
    </div>
    <script src="levels.js"></script>
    <script>
      const txt = document.getElementById("txt");
      const cv = document.getElementById("preview");
      const ctx = cv.getContext("2d");
      const TILE = 16;
      const allowed = new Set("#.sLlfxc ".split(""));

      const infoW = document.getElementById("infoW");
      const infoH = document.getElementById("infoH");
      const infoF = document.getElementById("infoF");
      const infoSl = document.getElementById("infoSl");
      const infoGl = document.getElementById("infoGl");
      const infoS = document.getElementById("infoS");
      const hintEl = document.getElementById("hint");

      const valStart = document.getElementById("valStart");
      const valExit = document.getElementById("valExit");
      const valRect = document.getElementById("valRect");
      const valChars = document.getElementById("valChars");

      const levelSel = document.getElementById("levelSel");
      const btnLevelAdd = document.getElementById("btnLevelAdd");
      const btnLevelDelete = document.getElementById("btnLevelDelete");
      const btnSaveAll = document.getElementById("btnSaveAll");
      const btnOpenFS = document.getElementById("btnOpenFS");
      const btnSaveFS = document.getElementById("btnSaveFS");
      let fileHandle = null; // FS Access handle for levels.js
      // --- Click Editor State ---
      const TOOLS = ["#", ".", "s", "l", "L", "f", "x", "c"];
      let BRUSH = "#";
      let isDown = false;
      let grid = null; // 2D array 20x30 of chars

      // Build 2D grid from current text
      function syncGridFromText() {
        const rows = normalize(txt.value).split("\n");
        grid = rows.map((r) => r.split(""));
      }
      function syncTextFromGrid() {
        if (!grid) return;
        const rows = grid.map((row) => row.join(""));
        txt.value = rows.join("\n");
      }

      // Palette wiring
      const palette = document.getElementById("palette");
      function setBrush(ch) {
        BRUSH = ch;
        if (palette) {
          palette.querySelectorAll(".tool").forEach((btn) => {
            btn.classList.toggle("selected", btn.dataset.ch === ch);
          });
        }
      }
      if (palette) {
        palette.addEventListener("click", (e) => {
          const btn = e.target.closest(".tool");
          if (!btn) return;
          setBrush(btn.dataset.ch);
        });
      }
      // default brush highlight after DOM ready
      setTimeout(() => setBrush("#"), 0);

      // Mouse painting on preview canvas
      cv.addEventListener("contextmenu", (e) => e.preventDefault());
      cv.addEventListener("mousedown", (e) => {
        isDown = true;
        handlePaintEvent(e);
      });
      window.addEventListener("mouseup", () => {
        isDown = false;
      });
      cv.addEventListener("mousemove", (e) => {
        if (isDown) handlePaintEvent(e);
      });

      function handlePaintEvent(e) {
        const rect = cv.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / (rect.width / cv.width));
        const y = Math.floor(
          (e.clientY - rect.top) / (rect.height / cv.height)
        );
        const tx = Math.floor(x / TILE);
        const ty = Math.floor(y / TILE);
        if (!grid) syncGridFromText();
        if (ty < 0 || ty >= 20 || tx < 0 || tx >= 30) return;
        let ch = BRUSH;
        if (e.button === 2 || BRUSH === "erase") ch = ".";

        // keep border walls if painting outside? allow overwrite; user can build borders
        grid[ty][tx] = ch;
        syncTextFromGrid();
        drawPreview(txt.value);
      }

      // Keyboard shortcuts 1..8 select tools in TOOLS
      window.addEventListener("keydown", (e) => {
        const idx = parseInt(e.key, 10);
        if (idx >= 1 && idx <= TOOLS.length) {
          setBrush(TOOLS[idx - 1]);
        } else if (e.key === "Escape" || e.key === "Backspace") {
          setBrush("erase");
        }
      });

      function buildLevelsJS() {
        // Sync aktuelle Edits in Arrays
        saveCurrentIntoArrays();
        // Alle Levels auf 30x20 normalisieren, TIPS-Länge anpassen
        LVLS = LVLS.map((s) => normalize(s));
        while (TIPSARR.length < LVLS.length)
          TIPSARR.push("Sammle alle Fische und gehe zur Tür.");
        if (TIPSARR.length > LVLS.length)
          TIPSARR = TIPSARR.slice(0, LVLS.length);
        const levelsBlock = LVLS.map(
          (s) => `\n\`${s.replace(/`/g, "\\`")}\`\n`
        ).join(",");
        const tipsBlock = TIPSARR.map(
          (t) => `  \`${(t || "").replace(/`/g, "\\`")}\``
        ).join(",\n");
        return `// Auto-exported by editor.html\nconst LEVELS = [${levelsBlock}\n];\n\nconst TIPS = [\n${tipsBlock}\n];\n`;
      }

      async function openLevelsFS() {
        if (!window.showOpenFilePicker) {
          alert(
            "Dein Browser unterstützt die File System Access API nicht. Nutze Chrome/Edge auf https:// oder localhost."
          );
          return;
        }
        try {
          const [handle] = await showOpenFilePicker({
            types: [
              {
                description: "JavaScript",
                accept: {
                  "application/javascript": [".js"],
                  "text/plain": [".js"],
                },
              },
            ],
            excludeAcceptAllOption: false,
            multiple: false,
          });
          fileHandle = handle;
          const file = await handle.getFile();
          const text = await file.text();
          // LEVELS/TIPS extrahieren (funktioniert mit const/var)
          const mod = new Function(
            text +
              '\n;return {LEVELS: (typeof LEVELS!="undefined"?LEVELS:(typeof window!="undefined"?window.LEVELS:undefined)), TIPS: (typeof TIPS!="undefined"?TIPS:(typeof window!="undefined"?window.TIPS:undefined))};'
          );
          const { LEVELS: LJs, TIPS: TJs } = mod();
          if (!Array.isArray(LJs)) throw new Error("LEVELS nicht gefunden.");
          LVLS = LJs.slice();
          TIPSARR = Array.isArray(TJs) ? TJs.slice() : [];
          while (TIPSARR.length < LVLS.length)
            TIPSARR.push("Sammle alle Fische und gehe zur Tür.");
          refreshSelect();
          loadLevel(0);
          alert("levels.js geladen.");
        } catch (e) {
          console.error(e);
          alert("Konnte levels.js nicht laden: " + e.message);
        }
      }

      async function saveLevelsFS() {
        if (!fileHandle) {
          alert("Bitte zuerst eine levels.js öffnen.");
          return;
        }
        try {
          const js = buildLevelsJS();
          const writable = await fileHandle.createWritable();
          await writable.write(js);
          await writable.close();
          alert("levels.js gespeichert.");
        } catch (e) {
          console.error(e);
          alert("Speichern fehlgeschlagen: " + e.message);
        }
      }

      // Starter example (used if no levels.js present)
      const EXAMPLE = `##############################
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      #............................#
      ##############################`;

      const LEVELS_GLOBAL =
        typeof LEVELS !== "undefined"
          ? LEVELS
          : typeof window !== "undefined"
          ? window.LEVELS
          : undefined;
      const TIPS_GLOBAL =
        typeof TIPS !== "undefined"
          ? TIPS
          : typeof window !== "undefined"
          ? window.TIPS
          : undefined;
      let LVLS =
        Array.isArray(LEVELS_GLOBAL) && LEVELS_GLOBAL.length
          ? LEVELS_GLOBAL.slice()
          : [EXAMPLE];
      let TIPSARR = Array.isArray(TIPS_GLOBAL) ? TIPS_GLOBAL.slice() : [];
      while (TIPSARR.length < LVLS.length)
        TIPSARR.push("Sammle alle Fische und gehe zur Tür.");

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }
      function emptyGrid() {
        return Array.from({ length: 20 }, () => ".".repeat(30)).join("\n");
      }

      function refreshSelect() {
        if (!levelSel) return;
        levelSel.innerHTML = LVLS.map(
          (_, i) => `<option value="${i}">Level ${i + 1}</option>`
        ).join("");
      }
      function loadLevel(i) {
        i = clamp(i | 0, 0, LVLS.length - 1);
        if (levelSel) levelSel.value = String(i);
        txt.value = LVLS[i] || emptyGrid();
        syncGridFromText();
        if (hintEl) hintEl.value = TIPSARR[i] || "";
        drawPreview(txt.value);
      }
      function saveCurrentIntoArrays() {
        const i = clamp(
          parseInt(levelSel?.value || "0", 10) || 0,
          0,
          LVLS.length - 1
        );
        syncTextFromGrid();
        LVLS[i] = normalize(txt.value);
        TIPSARR[i] = hintEl?.value || "Sammle alle Fische und gehe zur Tür.";
      }

      function setBadge(el, ok, text) {
        el.textContent = text;
        el.className = "badge " + (ok ? "ok" : "warn");
      }

      function normalize(text) {
        let rows = text
          .replace(/\s+$/gm, "")
          .replace(/^\n+|\n+$/g, "")
          .split("\n");
        const WIDTH = 30,
          HEIGHT = 20;

        // kürzen oder auffüllen
        rows = rows.map((r) => (r + ".".repeat(WIDTH)).slice(0, WIDTH));
        while (rows.length < HEIGHT) rows.push(".".repeat(WIDTH));
        if (rows.length > HEIGHT) rows = rows.slice(0, HEIGHT);

        return rows.join("\n");
      }

      function analyze(text) {
        const rows = normalize(text).split("\n");
        const h = rows.length;
        const w = rows.reduce((m, r) => Math.max(m, r.length), 0);
        // check for fixed 30x20 size
        const correct = w === 30 && h === 20;
        const flat = rows.join("");
        const okChars = [...flat].every((ch) => allowed.has(ch));
        const fish = [...flat].filter((ch) => ch === "f").length;
        const sl = [...flat].filter((ch) => ch === "l").length;
        const gl = [...flat].filter((ch) => ch === "L").length;
        const sh = [...flat].filter((ch) => ch === "s").length;
        const hasStart = flat.includes("c");
        const hasExit = flat.includes("x");
        infoW.textContent = w;
        infoH.textContent = h;
        infoF.textContent = fish;
        infoSl.textContent = sl;
        infoGl.textContent = gl;
        infoS.textContent = sh;
        setBadge(
          valStart,
          hasStart,
          "Start (c): " + (hasStart ? "OK" : "fehlt")
        );
        setBadge(valExit, hasExit, "Tür (x): " + (hasExit ? "OK" : "fehlt"));
        setBadge(
          valRect,
          correct,
          "Größe: " + w + "x" + h + " (soll 30x20 sein)"
        );
        setBadge(
          valChars,
          okChars,
          "Zeichen gültig: " + (okChars ? "ja" : "nein")
        );
        return {
          rows,
          w,
          h,
          correct,
          okChars,
          fish,
          sl,
          gl,
          sh,
          hasStart,
          hasExit,
        };
      }

      // --- Light/Cone helpers (mirrors game logic) ---
      function pointInCone(px, py, cx, cy, ang, fov, range) {
        const dx = px - cx,
          dy = py - cy;
        const dist = Math.hypot(dx, dy);
        if (dist > range) return false;
        const a = Math.atan2(dy, dx);
        const d = Math.atan2(Math.sin(a - ang), Math.cos(a - ang));
        return Math.abs(d) <= fov * 0.5;
      }
      function drawCone(ctx, src, isLamp) {
        const range = src.range,
          fov = src.fov;
        const angle = isLamp ? 0 : src.angle || 0;
        const x = isLamp && src.offX != null ? src.x + src.offX : src.x;
        const y = isLamp && src.offY != null ? src.y + src.offY : src.y;
        const a1 = angle - fov / 2,
          a2 = angle + fov / 2;
        const grad = ctx.createRadialGradient(x, y, 8, x, y, range);
        grad.addColorStop(0, "rgba(255,220,120,0.45)");
        grad.addColorStop(0.7, "rgba(255,210,110,0.18)");
        grad.addColorStop(1, "rgba(255,200,100,0.0)");
        ctx.save();
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(a1) * range, y + Math.sin(a1) * range);
        ctx.arc(x, y, range, a1, a2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      function inAnyLightPreview(px, py, lamps, guards) {
        for (const l of lamps) {
          if (
            pointInCone(px, py, l.x + l.offX, l.y + l.offY, 0, l.fov, l.range)
          )
            return true;
        }
        for (const g of guards) {
          if (pointInCone(px, py, g.x, g.y, g.angle || 0, g.fov, g.range))
            return true;
        }
        return false;
      }

      function drawPreview(text) {
        const { rows, w, h } = analyze(text);
        // size canvas to fit, but clamp to default if too small
        const W = Math.max(480, w * TILE);
        const H = Math.max(320, h * TILE);
        if (cv.width !== W) cv.width = W;
        if (cv.height !== H) cv.height = H;

        // background
        ctx.clearRect(0, 0, W, H);
        const g = ctx.createLinearGradient(0, 0, 0, H);
        g.addColorStop(0, "#0f1420");
        g.addColorStop(1, "#0b0e17");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);

        // draw
        const lamps = []; // {x,y,range,fov,offX,offY}
        const guards = []; // {x,y,range,fov,angle}
        const hides = []; // shadow tiles for emission preview
        for (let y = 0; y < h; y++) {
          const row = rows[y] || "";
          for (let x = 0; x < w; x++) {
            const ch = row[x] || " ";
            const px = x * TILE,
              py = y * TILE;
            if (ch === "#") {
              ctx.fillStyle = "#384152";
              ctx.fillRect(px, py, TILE, TILE);
            } else if (ch === "s") {
              ctx.fillStyle = "rgba(8,14,24,0.78)";
              ctx.fillRect(px, py, TILE, TILE);
            } else {
              ctx.fillStyle = "rgba(0,0,0,0.06)";
              ctx.fillRect(px, py, TILE, TILE);
            }

            // overlays and remember for light/hide logic
            if (ch === "l") {
              lamps.push({
                x: px + 8,
                y: py + 8,
                range: 120,
                fov: Math.PI / 3,
                offX: 10,
                offY: -11,
              });
              ctx.fillStyle = "#ffe6aa";
              ctx.fillRect(px + 6, py + 6, 4, 4);
            }
            if (ch === "L") {
              guards.push({
                x: px + 8,
                y: py + 8,
                range: 160,
                fov: Math.PI / 2,
                angle: 0,
              });
              ctx.fillStyle = "#cc4455";
              ctx.fillRect(px + 5, py + 5, 6, 6);
            }
            if (ch === "s") {
              hides.push({ x: px, y: py, w: TILE, h: TILE });
            }
            if (ch === "f") {
              ctx.fillStyle = "#ffd166";
              ctx.beginPath();
              ctx.arc(px + 8, py + 8, 3, 0, Math.PI * 2);
              ctx.fill();
            }
            if (ch === "x") {
              ctx.fillStyle = "#5fd08a";
              ctx.fillRect(px + 2, py + 2, 12, 12);
            }
            if (ch === "c") {
              ctx.fillStyle = "#9ec5ff";
              ctx.beginPath();
              ctx.arc(px + 8, py + 8, 3, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }

        // --- Light rendering layer (matching game cones) ---
        const prevComp = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = "lighter";
        for (const l of lamps) drawCone(ctx, l, true);
        for (const g of guards) drawCone(ctx, g, false);
        ctx.globalCompositeOperation = prevComp;

        // Soft blue emission on hide tiles if they are within any light cone
        for (const s of hides) {
          const cx = s.x + s.w,
            cy = s.y + s.h;

          ctx.fillStyle = "#4e4e4e";
          ctx.fillRect(s.x, s.y, s.w, s.h);
        }

        // grid
        ctx.strokeStyle = "rgba(255,255,255,0.05)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let x = 0; x <= w; x++) {
          ctx.moveTo(x * TILE + 0.5, 0);
          ctx.lineTo(x * TILE + 0.5, h * TILE);
        }
        for (let y = 0; y <= h; y++) {
          ctx.moveTo(0, y * TILE + 0.5);
          ctx.lineTo(w * TILE, y * TILE + 0.5);
        }
        ctx.stroke();
      }

      // Buttons / Actions
      document.getElementById("btnPreview").onclick = () =>
        drawPreview(txt.value);
      document.getElementById("btnValidate").onclick = () => analyze(txt.value);
      document.getElementById("btnCopy").onclick = () => {
        navigator.clipboard.writeText(normalize(txt.value));
      };
      document.getElementById("btnExportTXT").onclick = () => {
        const blob = new Blob([normalize(txt.value)], { type: "text/plain" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "level.txt";
        a.click();
        setTimeout(() => URL.revokeObjectURL(a.href), 1000);
      };
      document.getElementById("btnExportJS").onclick = () => {
        if (btnSaveAll) btnSaveAll.onclick();
      };

      if (levelSel)
        levelSel.onchange = () => loadLevel(parseInt(levelSel.value, 10) || 0);

      if (btnLevelAdd)
        btnLevelAdd.onclick = () => {
          saveCurrentIntoArrays();
          LVLS.push(emptyGrid());
          TIPSARR.push("Sammle alle Fische und gehe zur Tür.");
          refreshSelect();
          loadLevel(LVLS.length - 1);
        };

      if (btnLevelDelete)
        btnLevelDelete.onclick = () => {
          if (LVLS.length <= 1) {
            alert("Mindestens 1 Level muss bleiben.");
            return;
          }
          const idx = parseInt(levelSel.value, 10) || 0;
          if (!confirm(`Level ${idx + 1} wirklich löschen?`)) return;
          LVLS.splice(idx, 1);
          TIPSARR.splice(idx, 1);
          refreshSelect();
          loadLevel(clamp(idx, 0, LVLS.length - 1));
        };

      if (btnOpenFS) btnOpenFS.onclick = openLevelsFS;
      if (btnSaveFS) btnSaveFS.onclick = saveLevelsFS;
      if (btnSaveAll)
        btnSaveAll.onclick = () => {
          const js = buildLevelsJS();
          const blob = new Blob([js], { type: "application/javascript" });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "levels.js";
          a.click();
          setTimeout(() => URL.revokeObjectURL(a.href), 1000);
        };

      // Shortcuts
      txt.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && (e.altKey || e.metaKey)) {
          e.preventDefault();
          drawPreview(txt.value);
        }
        if ((e.key === "s" || e.key === "S") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          document.getElementById("btnExportJS").click();
        }
      });

      refreshSelect();
      loadLevel(0);
      if (hintEl && !hintEl.value)
        hintEl.value = "Sammle alle Fische und gehe zur Tür.";
    </script>
  </body>
</html>
